### Helper

function build_helper_ex(g::SelectNode)
    # TODO: check_node(g)
    helper_parts_ex = Expr(:ref, :Tuple, build_helper_parts(g)...)
    return quote
        Helper{SelectNode}($helper_parts_ex)
    end
end

"""
    `build_helper_parts(g::SelectNode)`

Returns a vector of `Expr` objects of the form

`:( (res_field, f, arg_fields) )`

one such `Expr` for each column selection/transformation specified in
`@select(tbl, ...)`.
"""
function build_helper_parts(g::SelectNode)
    helper_parts_exs = Vector{Expr}()
    for e in g.args
        # case in which arg is a column specification
        if isa(e, Symbol)
            res_field = QuoteNode(e)
            push!(helper_parts_exs,
                  :( ($res_field, Base.identity, [$res_field]) )
            )
        # case in which arg is a transformation
        elseif isa(e, Expr)
            res_field = QuoteNode(get_res_field(e))
            core_expr = get_value_expr(e)
            kernel_expr, arg_fields = build_kernel_ex(core_expr)
            push!(helper_parts_exs,
                  # Helper{MutateNode} part
                #   Expr(:tuple, res_field, anon_func_expr, esc(ind2sym))
                  :( ($res_field, $kernel_expr, $(esc(arg_fields))) )
            )
        end
    end
    return helper_parts_exs
end

### RHS

rhs_select(::typeof(Base.identity), tbl, arg_fields) = tbl[arg_fields[1]]
function rhs_select(f, tbl, arg_fields)
    # Pre-process table in terms of kernel and argument column names
    T, row_itr = _preprocess(f, tbl, arg_fields)

    # Pre-allocate the table's new column.
    n = length(tbl[arg_fields[1]])
    output = NullableArray(T, n)

    # Fill the new column in row-by-row.
    # @code_warntype _fill_output!(output, f, row_itr)
    apply_transformation!(output, f, row_itr)

    # Return the output
    return output
end

"""
Given a tuple-to-scalar function that should be used to generate the output of
a `@mutate` operation, iterate over the elements of a tuple iterator to
produce the individual scalar values generated by the tuple-to-scalar function.
Store each of these values in the passed-in NullableVector.

Note that this function automatically applies the "natural" lifting semantics,
in which an expression over nullables produces a null value if any of the
inputs are null-valued. Another function will need to written to handle the
more complicated case in which only some sub-expressions are lifted and others
must be evaluated using custom lifting semantics.

* TODO: Parallelize this when threading is available in Base Julia.
* TODO: See if using `@inbounds` improves performance.
"""
@noinline function apply_transformation!(
    output::NullableVector,
    f::Any,
    tuple_iterator::Any,
)::Void
    # Iterate over all of the rows of the tuple iterator.
    for (i, tpl) in enumerate(tuple_iterator)
        # Apply default lifting semantics by branching on hasnull(tpl).
        if hasnulls(tpl)
            output.isnull[i] = true
        else
            output.isnull[i] = false
            output.values[i] = f(map(unwrap, tpl))
        end
    end
    return
end
