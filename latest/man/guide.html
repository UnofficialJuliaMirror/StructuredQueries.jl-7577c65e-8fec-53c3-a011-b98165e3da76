<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Guide · StructuredQueries.jl documentation</title><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script></head><body><nav class="toc"><h1>StructuredQueries.jl</h1><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li class="current"><a class="toctext" href="guide.html">Guide</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Usage-1">Usage</a></li><li><a class="toctext" href="#Natively-Supported-Verbs-1">Natively Supported Verbs</a></li><li><a class="toctext" href="#Contexts-1">Contexts</a></li><li><a class="toctext" href="#Composition-1">Composition</a></li><li><a class="toctext" href="#Collection-1">Collection</a></li></ul></li><li><a class="toctext" href="examples.html">Examples</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/public.html">Public</a></li><li><span class="toctext">Internals</span><ul><li><a class="toctext" href="../lib/internals.html">Internals</a></li><li><a class="toctext" href="../lib/internals/query.html">Querying</a></li><li><a class="toctext" href="../lib/internals/graph.html">Graph Generation</a></li><li><a class="toctext" href="../lib/internals/node.html"><code>QueryNode</code></a></li><li><a class="toctext" href="../lib/internals/helper.html"><code>QueryHelper</code></a></li><li><a class="toctext" href="../lib/internals/expr.html">Expression Analysis</a></li><li><a class="toctext" href="../lib/internals/collect.html">Collection</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="guide.html">Guide</a></li></ul><a class="edit-page" href="https://github.com/davidagold/StructuredQueries.jl/tree/8a10abe99ca3d133dda265493b18c68e29df3429/docs/src/man/guide.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Guide-1" href="#Guide-1">Guide</a></h1><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>StructuredQueries is a registered package. Install it with</p><pre><code class="language-julia">Pkg.add(&quot;StructuredQueries&quot;)</code></pre><p>This package supports Julia 0.5.</p><h2><a class="nav-anchor" id="Usage-1" href="#Usage-1">Usage</a></h2><p>StructuredQueries.jl provides a generic framework for data manipulation in Julia. The center of this framework are the <code>@query</code> and <code>@collect</code> macros.</p><p>To express a query in SQ, one uses the <code>@query</code> macro:</p><pre><code class="language-none">@query qry</code></pre><p>where <code>qry</code> is Julia code that follows a certain structure that we will describe below.</p><p><code>qry</code> is parsed according to what we&#39;ll call a <em>query context</em>. By a <em>context</em> we mean a general semantics for Julia code that may differ from the semantics of the standard Julia environment. That is to say: though <code>qry</code> must be valid Julia syntax, the code is not run as it would were it executed outside of the <code>@query</code> macro. Rather, code such as <code>qry</code> that occurs inside of a query context is subject to a number of transformations before it is run.</p><p>For instance, suppose <code>iris</code> names some tabular data source object (e.g. a <code>DataFrame</code>). We might express a query to produce a subset of the data that satisfies some predicate, say <code>sepal_length &gt; 5.0</code> with</p><pre><code class="language-none">julia&gt; q = @query filter(iris, sepal_length &gt; 5.0)
Query against a source of type DataFrames.DataFrame</code></pre><p>The structure of the query passed to <code>@query</code> consists of a <em>manipulation verb</em> (e.g. <code>filter</code>) that in turn takes a <em>data source argument</em> (e.g. <code>iris</code>) for its first argument and any number of <em>query arguments</em> (e.g. <code>sepal_length &gt; 5.0</code>) for its latter arguments. These are the three different &quot;parts&quot; of a query: (1) data sources (or just &quot;sources&quot;), (2) manipulation verbs (or just &quot;verbs&quot;), and (3) query arguments.</p><p>The <code>@query</code> macro transforms the code <code>filter(iris, sepal_length &gt; 5.0)</code> into code that produces a <code>Query</code> object that represents the structure of the query:</p><pre><code class="language-none">julia&gt; typeof(q)
StructuredQueries.Query

julia&gt; graph(q)
FilterNode
  arguments:
      1)  sepal_length &gt; 5.0
  inputs:
      1)  DataNode
            source:  source of type DataFrame</code></pre><h2><a class="nav-anchor" id="Natively-Supported-Verbs-1" href="#Natively-Supported-Verbs-1">Natively Supported Verbs</a></h2><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>By &quot;natively supported&quot;, we mean that the following verbs are recognized by the <code>@query</code> macro and properly incorporated into a graph representation.</p></div></div><ul><li><p><code>select</code></p></li><li><p><code>filter</code></p></li><li><p><code>groupby</code></p></li><li><p><code>summarize</code></p></li><li><p><code>orderby</code></p></li><li><p><code>innerjoin</code></p></li><li><p><code>leftjoin</code></p></li><li><p><code>outerjoin</code></p></li><li><p><code>crossjoin</code></p></li></ul><h2><a class="nav-anchor" id="Contexts-1" href="#Contexts-1">Contexts</a></h2><p>Each part of a query induces its own context in which code is evaluated. The most significant aspect of such contexts is name resolution. That is to say, names resolve differently depending on which part of a query they appear in and in what capacity they appear:</p><ul><li><p>In a data source specification context – e.g., as the first argument to a verb such as <code>filter</code> above – names are evaluated in the enclosing scope of the <code>@query</code> invocation. Thus, <code>iris</code> in the query used to define <code>q</code> above refers precisely to the <code>Table</code> object to which the name is bound in the top level of <code>Main</code>.</p></li><li><p>Names of manipulation verbs are not resolved to objects but rather merely signal how to construct the graphical representation of the query. (Indeed, in what follows there is no such function <code>filter</code> that is ever invoked in the execution of a query involving a <code>filter</code> clause.)</p></li><li><p>Names of functions called within a query argument context, such as <code>&gt;</code> in <code>sepal_length &gt; 5.0</code> are evaluated in the enclosing scope of the <code>@query</code> invocation.</p></li><li><p>Names that appear as arguments to function calls within a query argument context, such as <code>sepal_length</code> in <code>sepal_length &gt; 5.0</code> are not resolved to objects but are rather parsed as &quot;attributes&quot; of the data source (in this case, <code>iris</code>). When the data source is a tabular data structure, such attributes are taken to be column names, but such behavior is just a feature of a particular query semantics (see below in the section &quot;Roadmap and open questions&quot;.) The attributes that are passed as arguments to a given function call in a query argument are stored as data in the graphical query representation.</p></li></ul><h2><a class="nav-anchor" id="Composition-1" href="#Composition-1">Composition</a></h2><p>Manipulation verbs are composable in that an invocation of one verb may serve as a source argument to another verb:</p><pre><code class="language-none">julia&gt; @query select(filter(iris, sepal_length &gt; 5.0), species, petal_width)
Query against a source of type DataFrames.DataFrame

julia&gt; graph(ans)
SelectNode
  arguments:
      1)  species
      2)  petal_width
  inputs:
      1)  FilterNode
            arguments:
                1)  sepal_length &gt; 5.0
            inputs:
                1)  DataNode
                      source:  source of type DataFrame</code></pre><p>One can pipe arguments to verbs inside an <code>@query</code> context. For instance, the above <code>Query</code> is equivalent to that produced by</p><pre><code class="language-none">@query iris |&gt;
    filter(sepal_length &gt; 5.0) |&gt;
    select(species, petal_width)</code></pre><p>In this case, the first argument (i.e. <code>sepal_length &gt; 5.0</code>) to the verb <code>filter</code> is not a data source argument (e.g. <code>iris</code>, which is instead the first argument to <code>|&gt;</code>), but is rather a query argument.</p><p>If <code>q</code> is a <code>Query</code>, then invoking <code>@query q ...</code> simply extends the graph of <code>q</code> to include a representation of <code>...</code>:</p><pre><code class="language-none">julia&gt; f(q::Query) = @query q |&gt; groupby(species, petal_length &gt; 5.0)
f (generic function with 1 method)

julia&gt; f(@query filter(iris, sepal_length &gt; 5.0))
Query against a source of type DataFrames.DataFrame

julia&gt; graph(ans)
GroupbyNode
  arguments:
      1)  species
      2)  petal_length &gt; 5.0
  inputs:
      1)  FilterNode
            arguments:
                1)  sepal_length &gt; 5.0
            inputs:
                1)  DataNode
                      source:  source of type DataFrame</code></pre><h2><a class="nav-anchor" id="Collection-1" href="#Collection-1">Collection</a></h2><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>StructuredQueries.jl does not provide any sort of collection machinery; it only provides a query representation interface. Support for backend-specific collection machineries can be found either in data type hosting packages (e.g. <a href="https://github.com/davidagold/TablesDemo.jl"><code>TablesDemo.jl</code></a>) or in a collection interface package (e.g. <a href="https://github.com/davidagold/Collect.jl"><code>Collect.jl</code></a>)</p></div></div><p>To materialize the results of <code>q</code> as a concrete, in-memory Julia object, one calls</p><pre><code class="language-none">collect(q)</code></pre><footer><hr/><a class="previous" href="../index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="examples.html"><span class="direction">Next</span><span class="title">Examples</span></a></footer></article></body></html>
